=== メモ
集合:: `A`
論理クロックを共有する集まり:: `\rm{A}`

=== 着想


==== 2つの場合
まずAとBの2つだけで考えてみる。

AとBをとりあえず状態グループと呼ぶことにする。
同じ状態グループに属するノードは1つの「状態」を持つ。但し複数の状態グループに属する場合は，それぞれに状態を持てる。
その意味では「状態グループ」そのものが状態を持つと考えた方が良さそう。

[NOTE]
====
これを書いた時点で，私は位相空間についても線形論理についても何も知らない状態。
勉強してからもう一回考えてみると変わりそう。
====

素朴にはAとBの関係は以下のうちどれかである。

. AとBは無関係
. AはBに一方的に影響を及ぼす
. AとBは相互に影響する

まず，「AとBは無関係」の場合を latexmath:[\rm{A} - \rm{A}] と表記することにする。
これは，ある集合 latexmath:[A] と latexmath:[B] が互いに素であることと対応しそう。

次に，「AはBに一方的に影響を及ぼす」場合を， latexmath:[\rm{A} \rightarrow \rm{B}] と表記する事にする。
これは包含関係に対応するのか？ と考えたときに，どちら向きに包含されるのが良さそうかというと，そもそもAとBの定義を考える必要が出てくる。

試しに「内側 → 外側」の場合を考えると，「内側に影響されるならば外側に影響される」に対応する。逆に「外側 → 内側」の場合を考えると，「外側に影響を与えるなら内側に影響を与える」に対応する。
ここで，実際のプログラムが multi-reading には対応できるが multi-writing には対応が難しいことを考えると，前者が良さそう。

ここから，latexmath:[A \subset B] に対応させる。

問題はAとBが相互に影響する部分である。とりあえず latexmath:[\rm{A} \leftrightarrow \rm{B}] としてみる。
これを latexmath:[\rm{A} \rightarrow \rm{B} \land \rm{B} \rightarrow \rm{A}] と考えると，対応する集合は一つに潰れてしまう。
つまりAとBは1つの状態を持つという事に相当する。それでも整合性は取れるのだが，何も言っていないのと同じなので他の方法を考える。

何も言っていないという事について，「それを言い出したら結局は全体で一つの巨大な状態を持てば良い」という結論になってしまうためである。これは latexmath:[A] と latexmath:[B] を latexmath:[A \setminus B] と latexmath:[B \setminus A] と latexmath:[A \cap B] に分ければ解決するのだろうか？ つまり任意の2つについて「共通部分の集合」に相当する状態グループは少なくとも存在しそう。

NOTE: 考えるべきこととして「この集合の和集合や共通部分が正確には何であるか」などがある。

[line-through]#純粋なノードは全体集合 latexmath:[\mathcal{U}] に属する？# +
これは間違いで，純粋なノードは latexmath:[\perp] に属する。
何故ならば，それ自身以外の何も影響を与えないから，中に latexmath:[\prep] 以外のどんな集合も含んではならない。


==== 3つ以上の場合

純粋な閉路ができる可能性がある。これについては「時間差」を常に考えなくてはならない。また，どのように組んでも順序は実行ごとに変わる。

例えば以下のような影響グラフを考える

[graphviz,scaledwidth=30]
....
digraph G {
//  layout = circo
//  layout = dot
//  layout = fdp
    layout = neato
//  layout = osage
//  layout = sfdp
//  layout = twopi
    d -> e [dir="both"]
    f -> g [dir="both"]
    a -> d
    a -> b -> d -> f
    c -> e-> g
}
....

これは以下のようにも書ける。

[graphviz,scaledwidth=30]
....
digraph G {
    layout = neato
    ⊥ -> a [label="a"]
    ⊥ -> c [label="c"]
    d -> e [dir="both", label="*"]
    f -> g [dir="both", label="*"]
    a -> d [label="d*"]
    a -> b [label="b"]
    b -> d [label="d"]
    d -> f [label="f"]
    c -> e [label="e"]
    e -> g [label="g"]
}
....

推移的関係は省略ができ，また双方向の関係を「次の時間の」何かに接続することで以下のようにできる気がするのでしてみる。
二重の円で表現したノードは「戻る」ノード。これが何であるかは後々考える。

[graphviz,scaledwidth=40]
....
digraph G {
    layout = neato
    "d'" [shape = doublecircle]
    "e'" [shape = doublecircle]
    "f'" [shape = doublecircle]
    "g'" [shape = doublecircle]
    ⊥ -> a [label="a"]
    ⊥ -> c [label="c"]
    d -> "e'" [label="*"]
    e -> "d'" [label="*"]
    f -> "g'" [label="*"]
    g -> "f'" [label="*"]
    a -> d [label="d*"]
    a -> b [label="b"]
    b -> d [label="d"]
    d -> f [label="f"]
    c -> e [label="e"]
    e -> g [label="g"]
    d -> e [style = invis]
    f -> g [style = invis]
}
....

ここで気になるのは

. この「戻る」のは何であるか
. 上のグラフのどれで考えるのが良さそうか

辺りなので考えていく。
