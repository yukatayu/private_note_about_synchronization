=== メモ
集合:: `A`
論理クロックを共有する集まり:: `\rm{A}`

=== 着想


==== 2つの場合
まずAとBの2つだけで考えてみる。

AとBをとりあえず状態グループと呼ぶことにする。
同じ状態グループに属するノードは1つの「状態」を持つ。但し複数の状態グループに属する場合は，それぞれに状態を持てる。
その意味では「状態グループ」そのものが状態を持つと考えた方が良さそう。

[NOTE]
====
これを書いた時点で，私は位相空間についても線形論理についても何も知らない状態。
勉強してからもう一回考えてみると変わりそう。
====

素朴にはAとBの関係は以下のうちどれかである。

- AとBは無関係
- AはBに一方的に影響を及ぼす
- AとBは相互に影響する

まず，「AとBは無関係」の場合を latexmath:[\rm{A} - \rm{A}] と表記することにする。
これは，ある集合 latexmath:[A] と latexmath:[B] が互いに素であることと対応しそう。

次に，「AはBに一方的に影響を及ぼす」場合を， latexmath:[\rm{A} \rightarrow \rm{B}] と表記する事にする。
これは包含関係に対応するのか？ と考えたときに，どちら向きに包含されるのが良さそうかというと，そもそもAとBの定義を考える必要が出てくる。

試しに「内側 → 外側」の場合を考えると，「内側に影響されるならば外側に影響される」に対応する。逆に「外側 → 内側」の場合を考えると，「外側に影響を与えるなら内側に影響を与える」に対応する。
ここで，実際のプログラムが multi-reading には対応できるが multi-writing への対応は難しいことを考えると，前者が良さそう。

ここから，latexmath:[A \subset B] に対応させる。

問題はAとBが相互に影響する部分である。とりあえず latexmath:[\rm{A} \leftrightarrow \rm{B}] としてみる。
これを latexmath:[\rm{A} \rightarrow \rm{B} \land \rm{B} \rightarrow \rm{A}] と考えると，対応する集合は一つに潰れてしまう。
つまりAとBは1つの状態を持つという事に相当する。それでも整合性は取れるのだが，何も言っていないのと同じなので他の方法を考える。

何も言っていないという事について，「それを言い出したら結局は全体で一つの巨大な状態を持てば良い」という結論になってしまうためである。これは latexmath:[A] と latexmath:[B] を latexmath:[A \setminus B] と latexmath:[B \setminus A] と latexmath:[A \cap B] に分ければ解決するのだろうか？ つまり任意の2つについて「共通部分の集合」に相当する状態グループは少なくとも存在しそう。

NOTE: 考えるべきこととして「この集合の和集合や共通部分が正確には何であるか」などがある。

[line-through]#純粋なノードは全体集合 latexmath:[\mathcal{U}] に属する？# +
これは間違いで，純粋なノードは latexmath:[\perp] に属する。
何故ならば，それ自身以外の何も影響を与えないから，中に latexmath:[\prep] 以外のどんな集合も含んではならない。


==== 3つ以上の場合

純粋な閉路ができる可能性がある。これについては「時間差」を常に考えなくてはならない。また，どのように組んでも順序は実行ごとに変わる。

例えば以下のような影響グラフを考える

[graphviz,scaledwidth=30]
....
digraph G {
//  layout = circo
//  layout = dot
//  layout = fdp
    layout = neato
//  layout = osage
//  layout = sfdp
//  layout = twopi
    d -> e [dir="both"]
    f -> g [dir="both"]
    a -> d
    a -> b -> d -> f
    c -> e-> g
}
....

これは以下のようにも書ける。

[graphviz,scaledwidth=30]
....
digraph G {
    layout = neato
    ⊥ -> a [label="a"]
    ⊥ -> c [label="c"]
    d -> e [dir="both", label="*"]
    f -> g [dir="both", label="*"]
    a -> d [label="d*"]
    a -> b [label="b"]
    b -> d [label="d"]
    d -> f [label="f"]
    c -> e [label="e"]
    e -> g [label="g"]
}
....

推移的関係は省略ができ，また双方向の関係を「次の時間の」何かに接続することで以下のようにできる気がするのでしてみる。
二重の円で表現したノードは「戻る」ノード。これが何であるかは後々考える。

[graphviz,scaledwidth=40]
....
digraph G {
    layout = neato
    "d'" [shape = doublecircle]
    "e'" [shape = doublecircle]
    "f'" [shape = doublecircle]
    "g'" [shape = doublecircle]
    ⊥ -> a [label="a"]
    ⊥ -> c [label="c"]
    d -> "e'" [label="*"]
    e -> "d'" [label="*"]
    f -> "g'" [label="*"]
    g -> "f'" [label="*"]
    a -> b [label="b"]
    b -> d [label="d"]
    d -> f [label="f"]
    c -> e [label="e"]
    e -> g [label="g"]
    d -> e [style = invis]
    f -> g [style = invis]
}
....

ここで気になるのは

- この「戻る」ノードとは何であるか
- 上のグラフのどれで考えるのが良さそうか

辺りなので考えていく。

=== 実装から考える


[graphviz,scaledwidth=9]
....
digraph G {
    A -> B [label="msg"]
}
....

という状態の時に，2種類の考え方ができる

[grid="rows", options="autowidth"]
|===
|  msgベース | dom(msg) = A +
cod(msg) = B
| nodeベース | cod(A) = msg +
cos(B) = msg
|===

それぞれ雑に見て，実装できそうな物を考える。

msgベース:: msgに必要な実装とは？ +
--
- 同期
- 訂正，再送，暗号化，……
--

nodeベース:: 必要な実装は？ +
--
- 受け取ってどうするか？ 同期の要らないこと全て
--

==== そもそもmsgの受信をどう処理するか。

ここで例として，以下の2つを考える

- 方式1
.. `msg` は `buffer` を上書きする。
.. `buffer` は `status` を直接支配し，それが適宜出力する。
- 方式2
.. `status` は自分自身もしくは他の `status` を更新する
.. 更新された `status` は必ず出力を行う

また，方式1のうち，

- `msg` が無くても出力するかもしれない
- `msg` があっても出力しないかもしれない

の2つが考えられる。何かしら一般化できそう。

==== 具体的な考え1

いつも通り状態遷移を考える。

.msgの有無に関わらず出力するパターン
```
〇 → 〇 → 〇 → 〇 → 〇 → 〇
[val] ──→ [val'] ───→
     　　     ↑ msg
```

.msgが無いと出力しないパターン
```
〇 → × → × → 〇 → × → ×
[val] ─→ [val'] ───→
     　     ↑ msg
```

但し `×` は Wait。
この他にも，「出力するまで状態遷移させない」等もある。

[NOTE]
====
**「出力するまで状態遷移させない」について** +
これについて，キューしない場合は「msgの有無に関わらず出力するパターン」と同一である。
実際に，msgが少し遅れて到達した場合に同一になるので，区別することができない。 ^[要検証]^
====

直観的には

- `msg` が出力を阻害するかどうか (msgを待つかどうか)
- 出力が `msg` を阻害するかどうか (msgをキューするかどうか)

の2つの真理値でこれらは一般化できる。

これら4通りがそれぞれどのような状態遷移図を持つのか考えると，

「同期」： `msgはキューされる` ( `msg` を待つ):: 遷移とmsgが一対一対応の直線
`msg`はキューされる ( `msg` を待たない):: 各 `status` は恒等射を持つ
`msg` はキューされない ( `msg` を待つ):: 状態遷移を生成する `msg` は推移的 (ここで， latexmath:[g \circ f] は latexmath:[g] になる。分かりやすく書くと latexmath:[\xrightarrow{f} \circ \xrightarrow{g} = \xrightarrow{g}] )
`msg` はキューされない ( `msg` を待たない):: 上記に加えて `status` が恒等射を持つ

つまり，

|===
| システムの性質 | 状態遷移の性質

| `msg` を待つかどうか | 遷移が反射的かどうか
| `msg` をキューするかどうか | 遷移が推移的かどうか
|===

に相当しそうに見える。


